/**
 * Wizard Step 3 - Technical Interview
 * 
 * Mandatory technical interview to gather context for accurate estimation.
 * Questions are generated by AI based on requirement description and tech preset.
 */

import { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
    ArrowLeft,
    ArrowRight,
    AlertCircle,
    RefreshCw,
    MessageSquareCode
} from 'lucide-react';
import { useRequirementInterview } from '@/hooks/useRequirementInterview';
import {
    RequirementInterviewStep,
    InterviewLoading,
    EstimationResultStep
} from '@/components/estimation/interview';
import type { WizardData } from '@/hooks/useWizardState';

interface WizardStepInterviewProps {
    data: WizardData;
    onUpdate: (updates: Partial<WizardData>) => void;
    onNext: () => void;
    onBack: () => void;
}

type InterviewPhase = 'loading' | 'interviewing' | 'generating' | 'result' | 'error';

export function WizardStepInterview({
    data,
    onUpdate,
    onNext,
    onBack
}: WizardStepInterviewProps) {
    const [phase, setPhase] = useState<InterviewPhase>('loading');
    const [localError, setLocalError] = useState<string | null>(null);

    const interview = useRequirementInterview();

    // Generate questions on mount if not already done
    useEffect(() => {
        if (data.interviewQuestions && data.interviewQuestions.length > 0) {
            // Already have questions, restore state
            setPhase('interviewing');
        } else if (data.description && data.techPresetId && data.techCategory) {
            // Need to generate questions
            generateQuestions();
        }
    }, []);

    const generateQuestions = useCallback(async () => {
        setPhase('loading');
        setLocalError(null);

        const success = await interview.generateQuestions(
            data.description,
            data.techPresetId,
            data.techCategory,
            data.projectContext
        );

        if (success) {
            // Save questions to wizard state
            onUpdate({
                interviewQuestions: interview.questions,
                interviewReasoning: interview.reasoning,
                estimatedComplexity: interview.estimatedComplexity,
            });
            setPhase('interviewing');
        } else {
            setLocalError(interview.error || 'Failed to generate interview questions');
            setPhase('error');
        }
    }, [data.description, data.techPresetId, data.techCategory, interview, onUpdate]);

    const handleAnswerQuestion = useCallback((questionId: string, value: string | string[] | number) => {
        interview.answerQuestion(questionId, value);

        // Persist answers to wizard state
        const answersRecord: Record<string, any> = {};
        interview.answers.forEach((answer, key) => {
            answersRecord[key] = answer;
        });
        onUpdate({ interviewAnswers: answersRecord });
    }, [interview, onUpdate]);

    const handleInterviewComplete = useCallback(async () => {
        setPhase('generating');

        const result = await interview.generateEstimate(
            data.description,
            data.techPresetId,
            data.techCategory
        );

        if (result && result.success) {
            // Save estimation result to wizard state
            const activityCodes = result.activities.map(a => a.code);

            onUpdate({
                title: result.generatedTitle || undefined,
                selectedActivityCodes: activityCodes,
                aiSuggestedActivityCodes: activityCodes,
                activityBreakdown: result.activities,
                suggestedDrivers: result.suggestedDrivers,
                suggestedRisks: result.suggestedRisks,
                confidenceScore: result.confidenceScore,
                aiAnalysis: result.reasoning, // Save AI reasoning/analysis
            });

            setPhase('result');
        } else {
            setLocalError(result?.error || interview.error || 'Failed to generate estimate');
            setPhase('error');
        }
    }, [data.description, data.techPresetId, data.techCategory, interview, onUpdate]);

    const handleConfirmEstimate = useCallback(() => {
        // Move to next step (Drivers & Risks)
        onNext();
    }, [onNext]);

    const handleAdjustEstimate = useCallback(() => {
        // Move to next step for driver/risk adjustment
        onNext();
    }, [onNext]);

    const handleBackToInterview = useCallback(() => {
        setPhase('interviewing');
    }, []);

    const handleRetry = useCallback(() => {
        interview.reset();
        generateQuestions();
    }, [interview, generateQuestions]);

    // Render based on phase
    if (phase === 'loading') {
        return (
            <div className="flex flex-col h-full">
                <InterviewLoading techCategory={data.techCategory} />
            </div>
        );
    }

    if (phase === 'error') {
        return (
            <div className="flex flex-col h-full gap-4 items-center justify-center p-8">
                <div className="w-16 h-16 rounded-full bg-red-100 flex items-center justify-center">
                    <AlertCircle className="w-8 h-8 text-red-600" />
                </div>
                <div className="text-center space-y-2">
                    <h3 className="text-lg font-semibold text-slate-900">
                        Errore durante l'interview
                    </h3>
                    <p className="text-slate-500 max-w-md">
                        {localError || 'Si è verificato un errore. Riprova.'}
                    </p>
                </div>
                <div className="flex gap-3 mt-4">
                    <Button variant="outline" onClick={onBack}>
                        <ArrowLeft className="w-4 h-4 mr-2" />
                        Torna al Preset
                    </Button>
                    <Button onClick={handleRetry}>
                        <RefreshCw className="w-4 h-4 mr-2" />
                        Riprova
                    </Button>
                </div>
            </div>
        );
    }

    if (phase === 'generating') {
        return (
            <div className="flex flex-col h-full items-center justify-center gap-4">
                <div className="w-16 h-16 rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center animate-pulse">
                    <MessageSquareCode className="w-8 h-8 text-white" />
                </div>
                <div className="text-center">
                    <h3 className="text-lg font-semibold text-slate-900">
                        Generazione stima in corso...
                    </h3>
                    <p className="text-slate-500 mt-1">
                        Analisi delle risposte e selezione attività
                    </p>
                </div>
            </div>
        );
    }

    if (phase === 'result' && interview.estimateResult) {
        return (
            <div className="flex flex-col h-full overflow-auto">
                <EstimationResultStep
                    result={interview.estimateResult}
                    onConfirm={handleConfirmEstimate}
                    onAdjust={handleAdjustEstimate}
                    onBack={handleBackToInterview}
                />
            </div>
        );
    }

    // Phase: interviewing
    return (
        <div className="flex flex-col h-full overflow-auto">
            <RequirementInterviewStep
                questions={interview.questions.length > 0 ? interview.questions : (data.interviewQuestions || [])}
                currentIndex={interview.currentQuestionIndex}
                answers={interview.answers}
                reasoning={interview.reasoning || data.interviewReasoning}
                estimatedComplexity={interview.estimatedComplexity || data.estimatedComplexity}
                onAnswer={handleAnswerQuestion}
                onNext={interview.nextQuestion}
                onPrevious={interview.previousQuestion}
                onComplete={handleInterviewComplete}
                onBack={onBack}
                canProceed={interview.canProceed}
                isFirstQuestion={interview.isFirstQuestion}
                isLastQuestion={interview.isLastQuestion}
                isGenerating={false}
            />
        </div>
    );
}
